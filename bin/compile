#!/bin/bash
# usage: bin/compile <build-dir> <cache-dir> <env-dir>

set -eo pipefail

[ "$BUILDPACK_XTRACE" ] && set -o xtrace

mkdir -p "$1" "$2"
build=$(cd "$1/" && pwd)
cache_root=$(cd "$2/" && pwd)
cache="${cache_root}/.heroku/go"
mkdir -p "${cache}"
env_dir="${3}"
buildpack=$(cd "$(dirname $0)/.." && pwd)

source "${buildpack}/lib/common.sh"

# Used by buildpack-stdlib
BPLOG_PREFIX="buildpack.go"
source "${buildpack}/vendor/buildpack-stdlib_v8.sh"

# Set CACHE_DIR (used by build_data)
CACHE_DIR="${cache_root}"
source "${buildpack}/lib/build_data.sh"

compile_start_time=$(build_data::current_unix_realtime)

# Initialise the build data store used to track state across builds (for cache invalidation
# and messaging when build configuration changes) and also so that `bin/report` can generate
# a build report that will be consumed by the build system for observability.
build_data::setup

snapshotBinBefore

# Clean up old cache files if migrating from old cache structure.
# We detect this legacy structure by looking for 'go-path' in the root.
if [ -d "${cache_root}/go-path" ] && [ ! -d "${cache}/go-path" ]; then
    step "Clearing old build cache artifacts"

    # Remove artifacts that were previously stored in the cache root
    rm -rf "${cache_root}"/go[0-9]* \
           "${cache_root}"/devel-* \
           "${cache_root}/go-path" \
           "${cache_root}/go-build-cache" \
           "${cache_root}/glide" \
           "${cache_root}/gb" \
           "${cache_root}/dep" \
           "${cache_root}/godep" \
           "${cache_root}/govendor" \
           "${cache_root}/.tq" \
           "${cache_root}/.jq" \
           "${cache_root}/github.com/golang-migrate" \
           "${cache_root}/github.com/mattes" 2>/dev/null || true
fi

DefaultGoVersion="$(<${DataJSON} jq -r '.Go.DefaultVersion')"

handleDefaultPkgSpec() {
    if [ "${pkgs}" = "default" ]; then
        warn "Installing package '.' (default)"
        warn ""
        warn "To install a different package spec add a comment in the following form to your \`go.mod\` file:"
        warn "// +heroku install ./cmd/..."
        warn ""
        pkgs="."
    fi
}

# TODO: go1 is missing from storage.googleapis.com and we haven't manually compiled it yet
urlFor() {
    local ver=$1
    case $ver in
        devel*)
            local sha=$(echo ${ver} | cut -d - -f 2)  #assumes devel-<short sha> or devel-<full sha>
            echo https://github.com/golang/go/archive/$sha.tar.gz
        ;;
        *)
            local file="${ver}.linux-amd64.tar.gz"
            echo ${BucketURL}/${file}
        ;;
    esac
}

# Expand a version identifier to supported versions of Go. If the version
# identifier starts with one or more digits, then "go" is prepended before
# expansion. So `1.9` => `go1.9`, `1.9.4` => `go1.9.4`, `devel` => `devel`. See
# data.json for supported expansions. All others are returned as is without go
# prepended to it.
expandVer() {
    local v="${1}"
    if [[ "${v}" =~ ^[[:digit:]]+ ]]; then
        v="go${v}"
    fi
    echo $(<${DataJSON} jq -r 'if .Go.VersionExpansion."'${v}'" then .Go.VersionExpansion."'${v}'" else "'${v}'" end')
}

# Report development versions to user
# Use after expandVer
reportVer() {
    local ver="${1}"
    mcount "version.go.$ver"

    case $ver in
        devel*)
            warn ""
            warn "You are using a development build of Go."
            warn "This is provided for users requiring an unreleased Go version"
            warn "but is otherwise unsupported."
            warn ""
            warn "Build tests are NOT RUN!!"
            warn ""
        ;;
    esac
}

ensureGo() {
    local goVersion="${1}"
    local goPath="${cache}/${goVersion}/go"
    local goFile=""
    local txt="Installing ${goVersion}"
    if [ -d "${goPath}" ]; then
        step "Using ${goVersion}"
    else
        #For a go version change, we delete everything in our namespace
        step "New Go Version, clearing old cache"
        if [ -d "${cache}/go-path" ]; then
            find "${cache}/go-path" ! -perm -u=w -print0 | xargs -r -0 chmod u+w 2>&1
        fi
        rm -rf ${cache}/*
        case "${goVersion}" in
            devel*)
                local bGoVersion="$(expandVer ${DefaultGoVersion})"
                goFile="${bGoVersion}.linux-amd64.tar.gz"
                goPath="${cache}/${bGoVersion}/go"
                txt="Installing bootstrap ${bGoVersion}"
            ;;
            go1)
                goFile="go.go1.linux-amd64.tar.gz"
            ;;
            *)
                goFile="${goVersion}.linux-amd64.tar.gz"
            ;;
        esac

        step "${txt}"
        ensureFile "${goFile}" "${goPath}" "tar -C ${goPath} --strip-components=1 -zxf"
        rm -f "${goPath}/${goFile}"

        case "${goVersion}" in
            devel*)
                pushd "${cache}" &> /dev/null
                    mkdir -p "${goVersion}"
                    pushd "${goVersion}" &> /dev/null
                        local sha=$(echo ${goVersion} | cut -d - -f 2)  #assumes devel-<short sha> or devel-<full sha>
                        local url="https://github.com/golang/go/archive/$sha.tar.gz"
                        start "Downloading development Go version ${goVersion}"
                            ${CURL} ${url} | tar zxf -
                            mv go-${sha}* go
                        finished
                        step "Compiling development Go version ${goVersion}"
                        pushd go/src &> /dev/null
                            echo "devel +${sha} $(date "+%a %b %H:%M:%S %G %z")"> ../VERSION
                            GOROOT_BOOTSTRAP=$(pushd ${cache}/${bGoVersion}/go > /dev/null; pwd; popd > /dev/null) ./make.bash 2>&1
                        popd &> /dev/null
                        go/bin/go version
                        rm -rf "${goPath}"
                    popd &> /dev/null
                popd &> /dev/null
                goPath="${cache}/${goVersion}/go"
            ;;
            *)
            ;;
        esac
    fi

    export GOROOT="${goPath}"
    PATH="${goPath}/bin:${PATH}"

    # Export GOCACHE if Go >= 1.10
    if go env | grep -q '^GOCACHE='; then
      export GOCACHE="${cache}/go-build-cache"
    fi
}

warnGoVersionOverride() {
    if [ ! -z "${GOVERSION}" ]; then
        warn "Using \$GOVERSION override."
        warn "     \$GOVERSION = ${GOVERSION}"
        warn ""
        warn "If this isn't what you want please run:'"
        warn "  heroku config:unset GOVERSION -a <app>"
        warn ""
    fi
}

warnPackageSpecOverride() {
    if [ ! -z "${GO_INSTALL_PACKAGE_SPEC}" ]; then
        warn "Using \$GO_INSTALL_PACKAGE_SPEC override."
        warn "     \$GO_INSTALL_PACKAGE_SPEC = ${GO_INSTALL_PACKAGE_SPEC}"
        warn ""
        warn "If this isn't what you want please run:'"
        warn "  heroku config:unset GO_INSTALL_PACKAGE_SPEC -a <app>"
        warn ""
    fi
}

installPkgs() {
    step "Running: go install -v ${FLAGS[@]} ${pkgs}"
    go install -v "${FLAGS[@]}" ${pkgs} 2>&1
}

loadEnvDir "${env_dir}"

setGitCredHelper "${env_dir}"
trap clearGitCredHelper INT TERM EXIT

FLAGS=(-tags heroku)

determineTool

# Track the requested version before expansion (for pinned check)
requested_go_version="${ver}"

# Expand the version and track the resolved version
ver=$(expandVer $ver)
build_data::set_string "go_version" "${ver}"

# Track whether the version was pinned (fully specified)
if [ "${requested_go_version}" = "${ver}" ]; then
    build_data::set_raw "go_version_pinned" "true"
else
    build_data::set_raw "go_version_pinned" "false"
fi

# If $GO_LINKER_SYMBOL and GO_LINKER_VALUE are set, tell the linker to DTRT
if [ -n "${GO_LINKER_SYMBOL}" -a -n "${GO_LINKER_VALUE}" ]; then
    FLAGS+=(-ldflags "-X ${GO_LINKER_SYMBOL}=${GO_LINKER_VALUE}")
fi

if [ -e "${build}/bin" -a ! -d "${build}/bin" ]; then
    err ""
    err "File bin exists and is not a directory."
    err ""
    exit 1
fi

reportVer "${ver}"

go_install_start_time=$(build_data::current_unix_realtime)
ensureGo "${ver}"
build_data::set_duration "go_install_duration" "${go_install_start_time}"

mkdir -p "${build}/bin"

export GOPATH

mcount "pkgmanagement.$TOOL"

mainPackagesInModule() {
  # For an explanation of what this is doing, see https://dave.cheney.net/2014/09/14/go-list-your-swiss-army-knife
  go list -find "${FLAGS[@]}" -f '{{ if eq .Name "main" }} {{.ImportPath}} {{ end }}' ./...
}

setupProcfile() {
    if [ -f "${build}/Procfile" ]; then
        return
    fi
    local pkgs=$(mainPackagesInModule)
    if [ -z "${pkgs}" ]; then
        return
    fi
    local pf=()
    for pkg in ${pkgs}; do
        local bn=$(basename ${pkg})
        pf+=("${bn}: bin/${bn}")
    done
    if [ ${#pf} -eq 0 ]; then
        return
    fi
    info ""
    info "Created a Procfile with the following entries:"
    if [ ${#pf[@]} -eq 1 ]; then
        local line="web: bin/$(echo ${pf[0]} | cut -d / -f 2)"
        echo "${line}" > ${build}/Procfile
        info "\t\t${line}"
    elif [ ${#pf[@]} -gt 1 ]; then
        for pfl in "${pf[@]}"; do
            echo "${pfl}" >> ${build}/Procfile
            info "\t\t${pfl}"
        done
    fi
    info ""
    info "If these entries look incomplete or incorrect please create a Procfile with the required entries."
    info "See https://devcenter.heroku.com/articles/procfile for more details about Procfiles"
    info ""
}

dependencies_install_start_time=$(build_data::current_unix_realtime)

cd ${build}

export GOBIN="${build}/bin"
if [ "${GO_SETUP_GOPATH_FOR_MODULE_CACHE}" = "true" ]; then
    export GOPATH="${build}/.heroku/go-path"
    mkdir -p $GOPATH # ensure that it's created
else
    export GOPATH="${cache}/go-path"
fi

# TODO: Check the desired language version (eg `go mod edit -json | jq -r '.Go'`)
# and only do this if it's <1.14. The 1.14 release and beyond handles this automatically
# when the desired language version is 1.14+ and vendoring should be used.
# https://golang.org/doc/go1.14#vendor
if [ -d "${build}/vendor" -a -s "${build}/go.sum" ]; then
    FLAGS+=(-mod=vendor)
fi

step "Determining packages to install"
pkgs=${GO_INSTALL_PACKAGE_SPEC:-$(awk '{ if ($1 == "//" && $2 == "+heroku" && $3 == "install" ) { print substr($0, index($0,$4)); exit }}' ${goMOD})}
if [ -z "${pkgs}" ]; then
    pkgs=$(mainPackagesInModule)
    if [ -z "${pkgs}" ]; then
        warn ""
        warn "No main packages found in module ${name}"
        warn ""
        warn "Unsure what package(s) to install, defaulting to '.'"
        warn ""
        pkgs="default"
        mcount "pkginstall.detect-failed"
    else
        info ""
        info "Detected the following main packages to install:"
        for pkg in ${pkgs}; do
            info "\t\t${pkg}"
        done
        info ""
        mcount "pkginstall.auto"
    fi
else
    if [ -z "${GO_INSTALL_PACKAGE_SPEC}" ]; then
        mcount "pkginstall.go_install_package_spec"
    else
        mcount "pkginstall.heroku_install"
    fi
fi

if [[ "${pkgs}" =~ "..." ]]; then
    mcount "package_spec.contains.dot_dot_dot"
fi

warnPackageSpecOverride
handleDefaultPkgSpec

unset GIT_DIR # unset git dir or it will mess with goinstall
if [[ -f bin/go-pre-compile ]]; then
    step "Running bin/go-pre-compile hook"
    chmod a+x bin/go-pre-compile
    bin/go-pre-compile
fi

installPkgs

if [[ -f bin/go-post-compile ]]; then
    step "Running bin/go-post-compile hook"
    chmod a+x bin/go-post-compile
    bin/go-post-compile
fi

build_data::set_duration "dependencies_install_duration" "${dependencies_install_start_time}"

_newOrUpdatedBinFiles=$(binDiff)
info ""
info "Installed the following binaries:"
for fyle in ${_newOrUpdatedBinFiles}; do
  info "\t\t${fyle}"
done

setupProcfile

cd $build
mkdir -p $build/.profile.d
echo 'PATH=$PATH:$HOME/bin' > $build/.profile.d/go.sh

if [ "${GO_INSTALL_TOOLS_IN_IMAGE}" = "true" ]; then
    start "Copying go tool chain to \$GOROOT=\$HOME/.heroku/go"
        mkdir -p "${build}/.heroku/go"
        cp -a "${GOROOT}/"* "${build}/.heroku/go"
        echo 'export GOROOT=$HOME/.heroku/go' > "${build}/.profile.d/goroot.sh"
        echo 'PATH=$PATH:$GOROOT/bin' >> "${build}/.profile.d/goroot.sh"
    finished
fi

t="${build}/.heroku/go"
mkdir -p "${t}"
t="${t}/.meta"
echo "TOOL=${TOOL}" > "${t}"
echo "NAME=${name}" >> "${t}"

build_data::set_duration "total_duration" "${compile_start_time}"
